#include <Windows.h>
#include <iostream>

void _declspec(naked) shellcode() {
	_asm {
		//1.保存字符串信息
		//user32.dll、LoadLibraryA、GetProcAddress、MessageBoxA、hello 41hook、kernel32.dll
		// LoadLibraryA 0x0c917432
		// MessageBoxA 0x1e380a6a
		// ExitProcess 0x4fd18963
		//字符串00结尾
		pushad
		sub esp, 0x30

		//kernel32.dll
		//kernel32.dll 6B 65 72 6E   65 6C 33 32   2E 64 6C 6C  00 0xd
		mov byte ptr[esp - 1], 0x0
		sub esp, 0x1
		push 0x6c6c642e
		push 0x32336c65
		push 0x6e72656b

		//hello 41hook
		//hello 41hook 68 65 6C 6C   6F 20 34 31   68 6F 6F 6B   00 0xD
		mov byte ptr[esp - 1], 0x0
		sub esp, 0x1
		push 0x6b6f6f68
		push 0x3134206f
		push 0x6c6c6568


		//user32.dll
		//user32.dll  75 73 65 72    33 32 2E 64    6C 6C 00   0xB
		mov byte ptr[esp - 1], 0x0
		sub esp, 0x1
		mov word ptr[esp - 2], 0x6c6c
		sub esp, 0x2
		push 0x642E3233
		push 0x72657375


		mov ecx, esp //ecx指向字符串首地址？？？？？？？？可不可以直接push esq
		push ecx
		call fun_payload
		//popad




		//2. 通过fs寄存器获取kernel32.dll基址
		//函数中除了eax的其他寄存器如果要使用要在函数开头push并且函数结尾pop，
		//但eax不需要push，eax可以随意使用。
		//eax在函数中通常负责寄存器返回
	fun_GetModule:
		push ebp
		mov ebp, esp
		sub esp, 0xc
		push esi

		mov esi, dword ptr fs : [0x30] //获取PEB地址
		mov esi, [esi + 0xc] //获取LDR结构体地址
		mov esi, [esi + 0x1c]//list
		mov esi, [esi]//list第二项 kernel32.dll
		mov esi, [esi + 0x8]//kernel32.dll基址
		mov eax, esi //通常返回值放在eax中

		pop esi
		mov esp, ebp
		pop ebp
		retn


		//3. 获取导出表 根据导出表查找需要的函数
		//MyGetProcAddress(imageBase, hash)
		//ImageBase + 0x3C = NT头
		//NT头 + 0x78 = dataDirectory第一项 导出表
		//EAT = 导出表 + 0x1c
		//ENT = 导出表 + 0X20
		//EOT = 导出表 + 0x24
	fun_GetProcAddr:
		push ebp
		mov ebp, esp
		sub esp, 0x10
		push esi //EOT
		push edi //EOT
		push ebx
		push ecx //strlen
		push edx //imageBase

		mov edx, [ebp + 0x8]  //第一个参数imagebase（注意：+4是保存的返回地址）
		mov esi, [edx + 0x3c] //e_lfanew NT头偏移
		lea esi, [edx + esi] //NT头地址(imageBase + e_lfanew)
		lea esi, [esi + 0x18] //可选头地址
		mov esi, [esi + 0x60] //可选头地址+18+96=导出表RVA
		lea esi, [esi + edx] //export table VA
		mov edi, [esi + 0x1c] //EAT RVA
		lea edi, [edi + edx] //EAT VA
		mov[ebp - 0x4], edi //保存EAT VA,空出寄存器
		mov ebx, [esi + 0x20] //ENT RVA
		lea ebx, [ebx + edx] //ENT VA
		mov[ebp - 0x8], ebx //保存ENT VA,空出寄存器
		mov ecx, [esi + 0x24] //EOT RVA
		lea ecx, [ecx + edx] //EOT VA
		mov[ebp - 0xc], ecx //保存EOT VA,空出寄存器

		//4. 字符串比较函数
		// 直接利用cmp比较hashcode（dword）
		// 将所有要比较的函数名转换为hashcode
		xor ebx, ebx //ebx清零

	tag_cmp :
		mov edi, [ebp + 0xc] //hashcode参数
		mov esi, [ebp - 0x8] //ENT[0]地址
		mov esi, [esi + ebx * 4] //ENT[ebx]函数名RVA
		lea esi, [esi + edx] //ENT[ebx]函数名地址
		//mov[ebp - 0x10], esi //保存函数名地址
		//push [ebp - 0x10]
		push esi
		call fun_GetHashCode
		inc ebx
		cmp edi,eax //比较字符串
		jne tag_cmp //如果不相等继续比较下一个函数名

		// 如果相等则通过EOT获取EAT索引
		// 注意EOT是word
		dec ebx //ebx索引
		xor edi, edi //为了不影响结果清空edi
		mov esi, [ebp - 0xc] //EOT[0]地址
		mov di, [esi + ebx * 2] //EOT[ebx]序号 = EAT索引

		// 通过EAT索引获取函数地址
		mov esi, [ebp - 0x4] //EAT[0]地址
		mov esi, [esi + edi * 4] //EAT[edi]函数地址RVA
		lea eax, [esi + edx] //EAT[ebx]函数地址 

		pop edx
		pop ecx
		pop ebx
		pop edi
		pop esi
		mov esp, ebp
		pop ebp
		retn 0xc //清理参数堆栈（因为push进来了3个参数）

	fun_GetHashCode:
		push ebp
		mov ebp, esp
		sub esp, 0xc
		push esi
		push ebx
		push ecx
		push edx
		mov dword ptr[ebp - 0x4], 0

		//循环准备阶段
		mov esi, [ebp + 0x8] //strname地址
		xor eax, eax //eax清零
		xor ecx, ecx
	tag_loop :
		mov al, [esi + ecx] //获取第ecx个字符
		test al, al //检查是否为字符串结束符
		jz tag_out_loop //如果是字符串结束符则跳出循环
		mov ebx, [ebp - 0x4]
		shl ebx, 0x19 //左移25位
		mov edx, [ebp - 0x4]
		shr edx, 0x7 //右移7位
		or ebx, edx
		add ebx, eax //加上第一个字符
		mov[ebp - 0x4], ebx //保存到[ebp - 0x4]
		inc ecx
		jmp tag_loop //继续循环
	tag_out_loop :
		mov eax, [ebp - 0x4]
		pop edx
		pop ecx
		pop ebx
		pop esi
		mov esp, ebp
		pop ebp
		retn 0x4
		//5. payload函数
		//（stradd）通过调用以上各个功能实现输出hello51hook
		// 实际参数只有输入的字符串（地址）
	fun_payload:
		push ebp
		mov ebp, esp
		sub esp, 0x30
		push esi
		push edi
		push ebx
		push ecx
		push edx
		//1. 先拿到kernel32/kernelbase dllbase
		call fun_GetModule
		mov[ebp - 0x4], eax //保存kernel32/kernelbase dllbase
		//2. 获取LoadLibraryA
		push 0x0c917432 //LoadLibraryA hashcode
		push[ebp - 0x4] //kernel32/kernelbase dllbase
		call fun_GetProcAddr
		mov[ebp - 0x8], eax //保存LoadLibraryA地址
		//3. 调用LoadLibraryA 加载user32.dll
		mov ebx, [ebp + 0x8] //user32.dll
		push ebx
		call[ebp - 0x8] //调用LoadLibraryA获取 user32.dll base
		mov[ebp - 0xc], eax //user32.dll base
		//4. 调用fun_GetProcAddr 获取MessageBoxA地址
		push 0x1e380a6a //MessageABox hashcode
		push [ebp - 0xc] //user32.dll base
		call fun_GetProcAddr //获取MessageBoxA的函数地址
		mov[ebp - 0x10], eax //保存MessageBoxA地址
		//5. 输出hello 41hook
		push 0 //uType
		push 0 //uType
		mov ebx, [ebp + 0x8] //字符串首地址
		lea ebx, [ebx + 0xB]  //hello 41hook地址
		push ebx //lpText
		push 0 //lpText
		call[ebp - 0x10]
		
		//6.ExitProcess(只有kernel32有）
		// 6.1 LoadLibraryA加载kernel32
		mov ebx, [ebp + 0x8] //字符串首地址
		lea ebx, [ebx + 0x18] //kernel32.dll字符串地址
		push ebx
		call [ebp - 0x8] //调用LoadLibraryA
		mov[ebp - 0x14], eax //保存kernel32.dll base
		// 6.2 fun_GetProcAddr(kernel32+ExitProcess字符串）获取ExitProcess地址
		push 0x4fd18963
		push[ebp - 0x14] //kernel32.dll base
		call fun_GetProcAddr
		mov[ebp - 0x18], eax //保存ExitProcess地址

		// 6.3 调用ExitProcess
		push 0
		call [ebp - 0x18] //调用ExitProcess


		pop edx
		pop ecx
		pop ebx
		pop edi
		pop esi
		mov esp, ebp
		pop ebp
		retn 0x4
	}
}


int main() {
	printf("Hello, World!\n");
	//调用shellcode
	shellcode();
	return 0;
}