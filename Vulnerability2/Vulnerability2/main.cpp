#include <Windows.h>
#include <iostream>

void _declspec(naked) shellcode() {
	_asm {
		//1.保存字符串信息
		//user32.dll、LoadLibraryA、GetProcAddress、MessageBoxA、hello 41hook
		//字符串00结尾
		pushad
		sub esp, 0x30

		//hello 41hook
		//hello 41hook 68 65 6C 6C   6F 20 34 31   68 6F 6F 6B   00 0xD
		mov byte ptr[esp - 1], 0x0
		sub esp, 0x1
		push 0x6b6f6f68
		push 0x3134206f
		push 0x6c6c6568

		//MessageBoxA
		//MessageBoxA 4D 65 73 73   61 67 65 42   6F 78 41 00    0xC
		push 0x41786f
		push 0x42656761
		push 0x7373654d

		//GetProcAddress
		//GetProcAddress 47 65 74 50   72 6F 63 41   64 64 72 65   73 73 00  0xF
		mov byte ptr[esp - 1], 0x0
		sub esp, 0x1
		mov word ptr [esp - 2] , 0x7373
		sub esp, 0x2
		push 0x65726464
		push 0x41636f72
		push 0x50746547

		//LoadLibraryA
		//LoadLibraryA  4C 6F 61 64   4C 69 62 72   61 72 79 41   00  0xD
		mov byte ptr[esp - 1], 0x0
		sub esp, 0x1
		push 0x41797261
		push 0x7262694c
		push 0x64616f4c

		//user32.dll
		//user32.dll  75 73 65 72    33 32 2E 64    6C 6C 00   0xB
		mov byte ptr[esp - 1], 0x0
		sub esp, 0x1
		mov word ptr[esp-2],0x6c6c
		sub esp,0x2
		push 0x642E3233
		push 0x72657375


		mov ecx, esp //ecx指向字符串首地址？？？？？？？？可不可以直接push esq
		push ecx
		call fun_payload
		//popad



		
		//2. 通过fs寄存器获取kernel32.dll基址
		//函数中除了eax的其他寄存器如果要使用要在函数开头push并且函数结尾pop，
		//但eax不需要push，eax可以随意使用。
		//eax在函数中通常负责寄存器返回
	fun_GetModule:
		push ebp
		mov ebp,esp
		sub esp,0xc
		push esi

		mov esi, dword ptr fs:[0x30] //获取PEB地址
		mov esi, [esi + 0xc] //获取LDR结构体地址
		mov esi, [esi + 0x1c]//list
		mov esi, [esi]//list第二项 kernel32.dll
		mov esi, [esi+0x8]//kernel32.dll基址
		mov eax,esi //通常返回值放在eax中
		
		pop esi
		mov esp,ebp
		pop ebp
		retn


		//3. 获取导出表 根据导出表查找需要的函数
		//MyGetProcAddress(imageBase, funName, strlen)
		//ImageBase + 0x3C = NT头
		//NT头 + 0x78 = dataDirectory第一项 导出表
		//EAT = 导出表 + 0x1c
		//ENT = 导出表 + 0X20
		//EOT = 导出表 + 0x24
	fun_GetProcAddr:
		push ebp
		mov ebp, esp
		sub esp, 0x10
		push esi //EOT
		push edi //EOT
		push ebx 
		push ecx //strlen
		push edx //imageBase

		mov edx,[ebp+0x8]  //第一个参数imagebase（注意：+4是保存的返回地址）
		mov esi,[edx + 0x3c] //e_lfanew NT头偏移
		lea esi,[edx + esi] //NT头地址(imageBase + e_lfanew)
		lea esi,[esi+0x18] //可选头地址
		mov esi,[esi+0x60] //可选头地址+18+96=导出表RVA
		lea esi,[esi+edx] //export table VA
		mov edi,[esi+0x1c] //EAT RVA
		lea edi, [edi + edx] //EAT VA
		mov[ebp - 0x4], edi //保存EAT VA,空出寄存器
		mov ebx,[esi+0x20] //ENT RVA
		lea ebx, [ebx + edx] //ENT VA
		mov[ebp - 0x8], ebx //保存ENT VA,空出寄存器
		mov ecx, [esi + 0x24] //EOT RVA
		lea ecx,[ecx+edx] //EOT VA
		mov[ebp - 0xc], ecx //保存EOT VA,空出寄存器

		//4. 字符串比较函数
		// Repe cmpsb 字符比较，edi 与esi地址的值按字节进行比较,
		// ecx为0或者比较结果不相同时候停止DF循环。循环结束后将设置ZF标志位
		// ecx控制比较次数（即字符串长度）
		//比较函数名，和ENT中函数名循环比较
		
		xor eax, eax //eax清零
		
	tag_cmp:
		mov edi, [ebp + 0xc] //funname地址！！！！！！！！！！！！！！！！！！！
		mov ecx, [ebp + 0x10] //strlen！！！！！！！！！！！！！！！！！！！！
		cld //DF=0
		mov esi, [ebp - 0x8] //ENT[0]地址
		mov esi,[esi+eax*4] //ENT[eax]函数名RVA
		lea esi,[esi + edx] //ENT[eax]函数名
		inc eax

		repe cmpsb //比较字符串
		jne tag_cmp //如果不相等继续比较下一个函数名

		// 如果相等则通过EOT获取EAT索引
		// 注意EOT是word
		dec eax //eax索引
		xor edi,edi //为了不影响结果清空edi
		mov esi, [ebp - 0xc] //EOT[0]地址
		mov di,[esi + eax*2] //EOT[eax]序号 = EAT索引

		// 通过EAT索引获取函数地址
		mov esi, [ebp - 0x4] //EAT[0]地址
		mov esi,[esi+edi*4] //EAT[edi]函数地址RVA
		lea eax, [esi + edx] //EAT[eax]函数地址 

		pop edx
		pop ecx
		pop ebx
		pop edi
		pop esi
		mov esp, ebp
		pop ebp
		retn 0xc //清理参数堆栈（因为push进来了3个参数）

		

		//5. payload函数
		//（stradd）通过调用以上各个功能实现输出hello51hook
		// 实际参数只有输入的字符串（地址）
	fun_payload:
		push ebp
		mov ebp, esp
		sub esp, 0x30
		push esi 
		push edi 
		push ebx
		push ecx 
		push edx 
		//1. 先拿到kernel32/kernelbase dllbase
		call fun_GetModule
		mov [ebp-0x4],eax //保存kernel32/kernelbase dllbase
		//2. 获取LoadLibraryA
		push 0xd //strlen
		mov ebx, [ebp+0x8] //funname首地址（第一个参数）
		lea ebx, [ebx + 0xb] //LoadLibraryA
		push ebx //funname
		push[ebp - 0x4] //kernel32/kernelbase dllbase
		call fun_GetProcAddr
		mov [ebp-0x8], eax //保存LoadLibraryA地址
		//3. 获取GetProcAddress
		push 0xf //strlen
		lea ebx, [ebx + 0xd] //GetProcAddress	
		push ebx //funname
		push[ebp - 0x4] //kernel32/kernelbase dllbase
		call fun_GetProcAddr
		mov[ebp - 0xc], eax //保存GetProcAddress地址
		//4. 调用LoadLibraryA 加载user32.dll
		mov ebx, [ebp + 0x8] //user32.dll
		push ebx
		call [ebp - 0x8] //调用LoadLibraryA获取 user32.dll base
		mov[ebp - 0x10], eax //user32.dll base
		//5. 调用GetProcAddress 获取MessageBoxA地址
		mov ebx, [ebp + 0x8] //字符串首地址
		lea ebx, [ebx + 0x27] //MessageABox
		push ebx //funname
		push [ebp - 0x10] //user32.dll base
		call[ebp - 0xc] //获取MessageBoxA的函数地址
		mov [ebp - 0x14], eax //保存MessageBoxA地址
		//6. 输出hello 41hook
		push 0 //uType
		push 0 //uType
		mov ebx, [ebp + 0x8] //字符串首地址
		lea ebx, [ebx + 0x33] //MessageABox
		push ebx //lpText
		push 0 //lpText
		call [ebp - 0x14]




		pop edx
		pop ecx
		pop ebx
		pop edi
		pop esi
		mov esp, ebp
		pop ebp
		retn 0x4
	}
}


int mainv1() {
	printf("Hello, World!\n");
	//调用shellcode
	shellcode();
	return 0;
}