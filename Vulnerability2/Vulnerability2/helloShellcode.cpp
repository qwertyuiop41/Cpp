#include<windows.h>
#include<iostream>
void _declspec(naked)shellCode()
{

	__asm
	{
		//user32.dll 75 73 65 72 33 32 2E 64   6C 6C 00             长度：0xB

		//hello 51hook 68 65 6C 6C 6F 20 35 31 68 6F 6F 6B   00     长度：0xD
		// kernel32.dll 6B 65 72 6E  65 6C 33 32  2E 64 6C 6C 00
		//ExitProcess 0x4FD18963
		// LoadLibraryA:0XC917432
		//GetProcAddress:0XBBAFDF85
		// MessageBoxA:0x1E380A6A

		//1.保存字符串信息
		pushad
		sub esp, 0x30

		//kenerl32.dll

		mov byte ptr ds : [esp - 1] , 0x0
		sub esp, 0x1
		push 0x6C6C642E
		push 0x32336C65
		push 0x6E72656B

		//hello 51hook 字符串
		mov byte ptr ds : [esp - 1] , 0x0
		sub esp, 0x1
		push 0x6B6F6F68
		push 0x3135206F
		push 0x6c6c6568

		//user32.dll 字符串
		mov byte ptr ds : [esp - 1] , 0x0
		sub esp, 0x1
		mov ax, 0x6c6c
		mov word ptr ds : [esp - 2] , ax
		sub esp, 0x2
		push 0x642e3233
		push 0x72657375

		mov ecx, esp
		push ecx
		call fun_payload


		//popad
		//2.获取模块基址
	fun_GetModule:
		push ebp
			mov ebp, esp
			sub esp, 0xc
			push esi
			mov esi, dword ptr fs : [0x30]//PEB指针
			mov esi, [esi + 0xc]//LDR结构体地址
			mov esi, [esi + 0x1c]//list
			mov esi, [esi]//list的第二项 kernel32
			mov esi, [esi + 0x8]//dllbase
			mov eax, esi
			pop esi
			mov esp, ebp
			pop ebp
			retn

			//查找API函数：
			fun_GetProcAddr :
		push ebp
			mov ebp, esp
			sub esp, 0x20
			push esi
			push edi
			push edx
			push ebx
			push ecx

			mov edx, [ebp + 0X8]//dllbase
			mov esi, [edx + 0x3c]//lf_anew
			lea esi, [edx + esi]//Nt头
			mov esi, [esi + 0x78]//导出表RVA
			lea esi, [edx + esi]//导出表VA
			mov edi, [esi + 0x1c]//EAT RVA
			lea edi, [edx + edi]//EAT VA
			mov[ebp - 0x4], edi//eatva
			mov edi, [esi + 0x20]//ENT RVA
			lea edi, [edx + edi]//ENT va
			mov[ebp - 0x8], edi//ENTVA
			mov edi, [esi + 0x24]//EOT RVA
			lea edi, [edx + edi]//
			mov[ebp - 0xc], edi//EOTVA
			//比较字符串获取API
			xor eax, eax
			xor ebx, ebx
			cld
			jmp tag_cmpfirst
			tag_cmpLoop :
		inc ebx
			tag_cmpfirst :
		mov esi, [ebp - 0x8]//ENT
			mov esi, [esi + ebx * 4]//RVA
			lea esi, [edx + esi]//函数名称字符串地址
			mov edi, [ebp + 0xc]//要查找的目标函数名称哈希值

			push esi//传参
			call fun_hashCode//对ENT表函数名称进行编码
			cmp eax, edi//哈希值比较
			jne tag_cmpLoop

			mov esi, [ebp - 0xc]//eot
			xor edi, edi//为了不影响结果清空edi
			mov di, [esi + ebx * 2]//eat表索引
			mov edx, [ebp - 0x4]//eat
			mov esi, [edx + edi * 4]//函数地址rva
			mov edx, [ebp + 0x8]//dllbase
			lea eax, [edx + esi]//funaddr va

			pop ecx
			pop ebx
			pop edx
			pop edi
			pop esi
			mov esp, ebp
			pop ebp
			retn 0x8

			//hashCode部分
			fun_hashCode:
		push ebp
			mov ebp, esp
			sub esp, 0X4
			push ecx
			push edx
			push ebx
			mov dword ptr[ebp - 0x4], 0
			mov esi, [ebp + 0x8]
			xor ecx, ecx
			tag_hashLoop :
		xor eax, eax
			mov al, [esi + ecx]
			test al, al
			jz tag_end
			mov ebx, [ebp - 0x4]
			shl ebx, 0x19
			mov edx, [ebp - 0x4]
			shr edx, 0x7
			or ebx, edx
			add ebx, eax
			mov[ebp - 0x4], ebx
			inc ecx//ecx++
			jmp tag_hashLoop
			tag_end :
		mov eax, [ebp - 0x4]
			pop ebx
			pop edx
			pop ecx
			mov esp, ebp
			pop ebp
			retn 0x4

			//paylod部分
			fun_payload:
		push ebp
			mov ebp, esp
			sub esp, 0x30
			push esi
			push edi
			push edx
			push ebx
			push ecx

			//1.先拿到dllbase
			call fun_GetModule
			mov[ebp - 0x4], eax

			//2.获取LoadLibraryA

			push 0XC917432//LoadLibraryA 哈希值
			push eax
			call fun_GetProcAddr
			mov[ebp - 0x8], eax//LoadLibraryA 地址

			//3.获取GetProcAddress

			push 0xBBAFDF85//GetProcAddress 哈希值
			push[ebp - 0x4]//kener32.dllbase
			call fun_GetProcAddr
			mov[ebp - 0xc], eax//GetProcAddress 函数地址

			//4.调用LoadLibraryA 加载user32.dll
			mov ecx, [ebp + 0x8]
			push  ecx
			call[ebp - 0x8]//调用loadlibraya获取 user32.dll 
			mov[ebp - 0x10], eax//user32base

			//5.调用fun_GetProcAddr 获取MessageBoxA地址

			push  0x1E380A6A//MessageBoxA 哈希值
			push[ebp - 0x10]
			call fun_GetProcAddr//获取MessageBoxA的函数地址
			mov[ebp - 0x14], eax
			//6.输出hello 51hook
			push 0
			push 0
			mov ecx, [ebp + 0x8]
			lea ecx, [ecx + 0xB]//字符串hello 51hook偏移
			push ecx
			push 0
			call[ebp - 0x14]//MessageBoxA

			//通过loadLibraryA 获取kernel32.dll的基址 确保万无一失
			mov ecx, [ebp + 0x8]
			lea ecx, [ecx + 0x18]
			push ecx
			call[ebp - 0x8]//调用loadlibraya获取 user32.dll
			mov[ebp - 0x18], eax//kener32.dllbase

			//退出程序0x4FD18963
			push  0x4FD18963//ExitProcess 哈希值
			push[ebp - 0x18]
			call fun_GetProcAddr//获取ExitProcess的函数地址
			mov[ebp - 0x2c], eax
			push 0
			call[ebp - 0x2c]//调用 ExitProcess
			pop ecx
			pop ebx
			pop edx
			pop edi
			pop esi
			mov esp, ebp
			pop ebp
			retn 0x4
	}
}
int main1()
{
	printf("hello 51hook");
	shellCode();
	return 0;
}